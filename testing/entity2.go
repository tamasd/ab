package abtesting

import (
	"encoding/json"
	"errors"
	"net/http"
	"strconv"

	"github.com/lib/pq"
	"github.com/nbio/hitch"
	"github.com/tamasd/ab"
)

// AUTOGENERATED DO NOT EDIT

func NewTest2(Name string, Mail string) *Test2 {
	e := &Test2{
		Name: Name,
		Mail: Mail,
	}

	// HOOK: newTest2()

	return e
}

func EmptyTest2() *Test2 {
	return &Test2{}
}

var _ ab.Validator = &Test2{}

func (e *Test2) Validate() error {
	var err error

	// HOOK: validateTest2()

	return err
}

func (e *Test2) GetID() string {
	return e.UUID
}

var Test2NotFoundError = errors.New("test2 not found")

const test2Fields = "t.uuid, t.name, t.mail, t.bio, t.data"

func selectTest2FromQuery(db ab.DB, query string, args ...interface{}) ([]*Test2, error) {
	// HOOK: beforeTest2Select()

	entities := []*Test2{}

	rows, err := db.Query(query, args...)

	if err != nil {
		return entities, err
	}

	for rows.Next() {
		e := EmptyTest2()
		jsonData := ""

		if err = rows.Scan(&e.UUID, &e.Name, &e.Mail, &e.Bio, &jsonData); err != nil {
			return []*Test2{}, err
		}

		json.Unmarshal([]byte(jsonData), &e.Data)

		entities = append(entities, e)
	}

	// HOOK: afterTest2Select()

	return entities, err
}

func selectSingleTest2FromQuery(db ab.DB, query string, args ...interface{}) (*Test2, error) {
	entities, err := selectTest2FromQuery(db, query, args...)
	if err != nil {
		return nil, err
	}

	if len(entities) > 0 {
		return entities[0], nil
	}

	return nil, nil
}

func (e *Test2) Insert(db ab.DB) error {
	// HOOK: beforeTest2Insert()

	jsonData := ""

	bjsonData, _ := json.Marshal(e.Data)
	jsonData = string(bjsonData)
	err := db.QueryRow("INSERT INTO \"test2\"(name, mail, bio, data) VALUES($1, $2, $3, $4) RETURNING uuid", e.Name, e.Mail, e.Bio, jsonData).Scan(&e.UUID)

	// HOOK: afterTest2Insert()

	return err
}

func (e *Test2) Update(db ab.DB) error {
	// HOOK: beforeTest2Update()

	jsonData := ""

	bjsonData, _ := json.Marshal(e.Data)
	jsonData = string(bjsonData)
	result, err := db.Exec("UPDATE \"test2\" SET name = $1, mail = $2, bio = $3, data = $4 WHERE uuid = $5", e.Name, e.Mail, e.Bio, jsonData, e.UUID)
	if err != nil {
		return err
	}

	aff, err := result.RowsAffected()
	if err != nil {
		return err
	}

	if aff != 1 {
		return Test2NotFoundError
	}

	// HOOK: afterTest2Update()

	return nil
}

func (e *Test2) Delete(db ab.DB) error {
	// HOOK: beforeTest2Delete()

	res, err := db.Exec("DELETE FROM \"test2\" WHERE uuid = $1", e.UUID)
	if err != nil {
		return err
	}

	aff, err := res.RowsAffected()
	if err != nil {
		return err
	}

	if aff != 1 {
		return Test2NotFoundError
	}

	// HOOK: afterTest2Delete()

	return nil
}

func LoadTest2(db ab.DB, UUID string) (*Test2, error) {
	// HOOK: beforeTest2Load()

	e, err := selectSingleTest2FromQuery(db, "SELECT "+test2Fields+" FROM \"test2\" t WHERE t.uuid = $1", UUID)

	// HOOK: afterTest2Load()

	return e, err
}

func LoadAllTest2(db ab.DB, start, limit int) ([]*Test2, error) {
	// HOOK: beforeTest2LoadAll()

	entities, err := selectTest2FromQuery(db, "SELECT "+test2Fields+" FROM \"test2\" t ORDER BY UUID DESC LIMIT $1 OFFSET $2", limit, start)

	// HOOK: afterTest2LoadAll()

	return entities, err
}

type Service2 struct {
}

func (s *Service2) Register(h *hitch.Hitch) error {
	var err error

	listMiddlewares := []func(http.Handler) http.Handler{}

	postMiddlewares := []func(http.Handler) http.Handler{}

	getMiddlewares := []func(http.Handler) http.Handler{}

	putMiddlewares := []func(http.Handler) http.Handler{}

	deleteMiddlewares := []func(http.Handler) http.Handler{}

	// HOOK: beforeService2Register()

	if err != nil {
		return err
	}

	h.Get("/api/test2", s.test2ListHandler(), listMiddlewares...)

	h.Post("/api/test2", s.test2PostHandler(), postMiddlewares...)

	h.Get("/api/test2/:id", s.test2GetHandler(), getMiddlewares...)

	h.Put("/api/test2/:id", s.test2PutHandler(), putMiddlewares...)

	h.Delete("/api/test2/:id", s.test2DeleteHandler(), deleteMiddlewares...)

	// HOOK: afterService2Register()

	return err
}

func test2DBErrorConverter(err *pq.Error) ab.VerboseError {
	ve := ab.NewVerboseError(err.Message, err.Detail)

	// HOOK: convertTest2DBError()

	return ve
}

func (s *Service2) test2ListHandler() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		db := ab.GetDB(r)
		loadFunc := LoadAllTest2
		abort := false
		start := 0
		limit := 25
		if page := r.URL.Query().Get("page"); page != "" {
			pagenum, err := strconv.Atoi(page)
			ab.MaybeFail(r, http.StatusBadRequest, err)
			start = (pagenum - 1) * limit
		}

		// HOOK: beforeTest2ListHandler()

		if abort {
			return
		}

		entities, err := loadFunc(db, start, limit)
		ab.MaybeFail(r, http.StatusInternalServerError, ab.ConvertDBError(err, test2DBErrorConverter))

		// HOOK: afterTest2ListHandler()

		if abort {
			return
		}

		ab.Render(r).JSON(entities)
	})
}

func (s *Service2) test2PostHandler() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		entity := &Test2{}
		ab.MustDecode(r, entity)

		abort := false

		// HOOK: test2PostValidation()

		if abort {
			return
		}

		if err := entity.Validate(); err != nil {
			ab.Fail(r, http.StatusBadRequest, err)
		}

		db := ab.GetDB(r)

		err := entity.Insert(db)
		ab.MaybeFail(r, http.StatusInternalServerError, ab.ConvertDBError(err, test2DBErrorConverter))

		// HOOK: afterTest2PostInsertHandler()

		if abort {
			return
		}

		ab.Render(r).SetCode(http.StatusCreated).JSON(entity)
	})
}

func (s *Service2) test2GetHandler() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		id := hitch.Params(r).ByName("id")
		db := ab.GetDB(r)
		abort := false
		loadFunc := LoadTest2

		// HOOK: beforeTest2GetHandler()

		if abort {
			return
		}

		entity, err := loadFunc(db, id)
		ab.MaybeFail(r, http.StatusInternalServerError, ab.ConvertDBError(err, test2DBErrorConverter))
		if entity == nil {
			ab.Fail(r, http.StatusNotFound, nil)
		}

		// HOOK: afterTest2GetHandler()

		if abort {
			return
		}

		ab.Render(r).JSON(entity)
	})
}

func (s *Service2) test2PutHandler() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		id := hitch.Params(r).ByName("id")

		entity := &Test2{}
		ab.MustDecode(r, entity)

		if err := entity.Validate(); entity.UUID != id || err != nil {
			ab.Fail(r, http.StatusBadRequest, err)
		}

		db := ab.GetDB(r)
		abort := false

		// HOOK: beforeTest2PutUpdateHandler()

		if abort {
			return
		}

		err := entity.Update(db)
		ab.MaybeFail(r, http.StatusInternalServerError, ab.ConvertDBError(err, test2DBErrorConverter))

		// HOOK: afterTest2PutUpdateHandler()

		if abort {
			return
		}

		ab.Render(r).JSON(entity)
	})
}

func (s *Service2) test2DeleteHandler() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		id := hitch.Params(r).ByName("id")
		db := ab.GetDB(r)
		abort := false
		loadFunc := LoadTest2

		// HOOK: beforeTest2DeleteHandler()

		if abort {
			return
		}

		entity, err := loadFunc(db, id)
		ab.MaybeFail(r, http.StatusInternalServerError, ab.ConvertDBError(err, test2DBErrorConverter))
		if entity == nil {
			ab.Fail(r, http.StatusNotFound, nil)
		}

		// HOOK: insideTest2DeleteHandler()

		if abort {
			return
		}

		err = entity.Delete(db)
		ab.MaybeFail(r, http.StatusInternalServerError, ab.ConvertDBError(err, test2DBErrorConverter))

		// HOOK: afterTest2DeleteHandler()

		if abort {
			return
		}
	})
}

func (s *Service2) SchemaInstalled(db ab.DB) bool {
	found := ab.TableExists(db, "test2")

	// HOOK: afterTest2SchemaInstalled()

	return found
}

func (s *Service2) SchemaSQL() string {
	sql := "CREATE TABLE \"test2\" (\n" +
		"\t\"uuid\" uuid DEFAULT uuid_generate_v4() NOT NULL,\n" +
		"\t\"name\" character varying NOT NULL,\n" +
		"\t\"mail\" character varying NOT NULL,\n" +
		"\t\"bio\" text NOT NULL,\n" +
		"\t\"data\" jsonb NOT NULL,\n" +
		"\tCONSTRAINT test2_pkey PRIMARY KEY (uuid)\n);\n"

	// HOOK: afterTest2SchemaSQL()

	return sql
}
