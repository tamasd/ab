package abtesting

import (
	"encoding/json"
	"errors"
	"net/http"
	"strconv"

	"github.com/lib/pq"
	"github.com/nbio/hitch"
	"github.com/tamasd/ab"
)

// AUTOGENERATED DO NOT EDIT

func NewTest(Name *string, Mail *string) *Test {
	e := &Test{
		UUID:   new(string),
		Name:   Name,
		Mail:   Mail,
		Secret: new([]string),
		Bio:    new(string),
		Data:   new([]jsonStuff),
	}

	// HOOK: newTest()

	return e
}

func EmptyTest() *Test {
	return &Test{
		UUID:   new(string),
		Name:   new(string),
		Mail:   new(string),
		Secret: new([]string),
		Bio:    new(string),
		Data:   new([]jsonStuff),
	}
}

var _ ab.Validator = &Test{}

func (e *Test) Validate() error {
	var err error

	// HOOK: validateTest()

	return err
}

func (e *Test) GetID() string {
	return *e.UUID
}

var TestNotFoundError = errors.New("test not found")

const testFields = "t.uuid, t.name, t.mail, t.bio, t.data"

func selectTestFromQuery(db ab.DB, query string, args ...interface{}) ([]*Test, error) {
	// HOOK: beforeTestSelect()

	entities := []*Test{}

	rows, err := db.Query(query, args...)

	if err != nil {
		return entities, err
	}

	for rows.Next() {
		e := EmptyTest()
		jsonData := ""

		if err = rows.Scan(e.UUID, e.Name, e.Mail, e.Bio, &jsonData); err != nil {
			return []*Test{}, err
		}

		json.Unmarshal([]byte(jsonData), e.Data)

		entities = append(entities, e)
	}

	// HOOK: afterTestSelect()

	return entities, err
}

func selectSingleTestFromQuery(db ab.DB, query string, args ...interface{}) (*Test, error) {
	entities, err := selectTestFromQuery(db, query, args...)
	if err != nil {
		return nil, err
	}

	if len(entities) > 0 {
		return entities[0], nil
	}

	return nil, nil
}

func (e *Test) Insert(db ab.DB) error {
	// HOOK: beforeTestInsert()

	jsonData := ""

	bjsonData, _ := json.Marshal(e.Data)
	jsonData = string(bjsonData)
	err := db.QueryRow("INSERT INTO \"test\"(name, mail, bio, data) VALUES($1, $2, $3, $4) RETURNING uuid", *e.Name, *e.Mail, *e.Bio, jsonData).Scan(e.UUID)

	// HOOK: afterTestInsert()

	return err
}

func (e *Test) Update(db ab.DB) error {
	// HOOK: beforeTestUpdate()

	jsonData := ""

	bjsonData, _ := json.Marshal(e.Data)
	jsonData = string(bjsonData)
	result, err := db.Exec("UPDATE \"test\" SET name = $1, mail = $2, bio = $3, data = $4 WHERE uuid = $5", *e.Name, *e.Mail, *e.Bio, jsonData, *e.UUID)
	if err != nil {
		return err
	}

	aff, err := result.RowsAffected()
	if err != nil {
		return err
	}

	if aff != 1 {
		return TestNotFoundError
	}

	// HOOK: afterTestUpdate()

	return nil
}

func (e *Test) Delete(db ab.DB) error {
	// HOOK: beforeTestDelete()

	res, err := db.Exec("DELETE FROM \"test\" WHERE uuid = $1", e.UUID)
	if err != nil {
		return err
	}

	aff, err := res.RowsAffected()
	if err != nil {
		return err
	}

	if aff != 1 {
		return TestNotFoundError
	}

	// HOOK: afterTestDelete()

	return nil
}

func LoadTest(db ab.DB, UUID string) (*Test, error) {
	// HOOK: beforeTestLoad()

	e, err := selectSingleTestFromQuery(db, "SELECT "+testFields+" FROM \"test\" t WHERE t.uuid = $1", UUID)

	// HOOK: afterTestLoad()

	return e, err
}

func LoadAllTest(db ab.DB, start, limit int) ([]*Test, error) {
	// HOOK: beforeTestLoadAll()

	entities, err := selectTestFromQuery(db, "SELECT "+testFields+" FROM \"test\" t ORDER BY UUID DESC LIMIT $1 OFFSET $2", limit, start)

	// HOOK: afterTestLoadAll()

	return entities, err
}

type Service struct {
}

func (s *Service) Register(h *hitch.Hitch) error {
	var err error

	listMiddlewares := []func(http.Handler) http.Handler{}

	postMiddlewares := []func(http.Handler) http.Handler{}

	getMiddlewares := []func(http.Handler) http.Handler{}

	putMiddlewares := []func(http.Handler) http.Handler{}

	patchMiddlewares := []func(http.Handler) http.Handler{}

	deleteMiddlewares := []func(http.Handler) http.Handler{}

	// HOOK: beforeServiceRegister()

	if err != nil {
		return err
	}

	h.Get("/api/test", s.testListHandler(), listMiddlewares...)

	h.Post("/api/test", s.testPostHandler(), postMiddlewares...)

	h.Get("/api/test/:id", s.testGetHandler(), getMiddlewares...)

	h.Put("/api/test/:id", s.testPutHandler(), putMiddlewares...)

	h.Patch("/api/test/:id", s.testPatchHandler(), patchMiddlewares...)

	h.Delete("/api/test/:id", s.testDeleteHandler(), deleteMiddlewares...)

	// HOOK: afterServiceRegister()

	return err
}

func testDBErrorConverter(err *pq.Error) ab.VerboseError {
	ve := ab.NewVerboseError(err.Message, err.Detail)

	// HOOK: convertTestDBError()

	return ve
}

func (s *Service) testListHandler() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		db := ab.GetDB(r)
		loadFunc := LoadAllTest
		abort := false
		start := 0
		limit := 25
		if page := r.URL.Query().Get("page"); page != "" {
			pagenum, err := strconv.Atoi(page)
			ab.MaybeFail(r, http.StatusBadRequest, err)
			start = (pagenum - 1) * limit
		}

		// HOOK: beforeTestListHandler()

		if abort {
			return
		}

		entities, err := loadFunc(db, start, limit)
		ab.MaybeFail(r, http.StatusInternalServerError, ab.ConvertDBError(err, testDBErrorConverter))

		// HOOK: afterTestListHandler()

		if abort {
			return
		}

		ab.Render(r).JSON(entities)
	})
}

func (s *Service) testPostHandler() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		entity := &Test{}
		ab.MustDecode(r, entity)

		abort := false

		// HOOK: testPostValidation()

		if abort {
			return
		}

		if err := entity.Validate(); err != nil {
			ab.Fail(r, http.StatusBadRequest, err)
		}

		db := ab.GetDB(r)

		err := entity.Insert(db)
		ab.MaybeFail(r, http.StatusInternalServerError, ab.ConvertDBError(err, testDBErrorConverter))

		// HOOK: afterTestPostInsertHandler()

		if abort {
			return
		}

		ab.Render(r).SetCode(http.StatusCreated).JSON(entity)
	})
}

func (s *Service) testGetHandler() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		id := hitch.Params(r).ByName("id")
		db := ab.GetDB(r)
		abort := false
		loadFunc := LoadTest

		// HOOK: beforeTestGetHandler()

		if abort {
			return
		}

		entity, err := loadFunc(db, id)
		ab.MaybeFail(r, http.StatusInternalServerError, ab.ConvertDBError(err, testDBErrorConverter))
		if entity == nil {
			ab.Fail(r, http.StatusNotFound, nil)
		}

		// HOOK: afterTestGetHandler()

		if abort {
			return
		}

		ab.Render(r).JSON(entity)
	})
}

func (s *Service) testPutHandler() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		id := hitch.Params(r).ByName("id")

		entity := &Test{}
		ab.MustDecode(r, entity)

		if err := entity.Validate(); *entity.UUID != id || err != nil {
			ab.Fail(r, http.StatusBadRequest, err)
		}

		db := ab.GetDB(r)
		abort := false

		// HOOK: beforeTestPutUpdateHandler()

		if abort {
			return
		}

		err := entity.Update(db)
		ab.MaybeFail(r, http.StatusInternalServerError, ab.ConvertDBError(err, testDBErrorConverter))

		// HOOK: afterTestPutUpdateHandler()

		if abort {
			return
		}

		ab.Render(r).JSON(entity)
	})
}

func (s *Service) testPatchHandler() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ab.Fail(r, http.StatusNotImplemented, nil)
	})
}

func (s *Service) testDeleteHandler() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		id := hitch.Params(r).ByName("id")
		db := ab.GetDB(r)
		abort := false
		loadFunc := LoadTest

		// HOOK: beforeTestDeleteHandler()

		if abort {
			return
		}

		entity, err := loadFunc(db, id)
		ab.MaybeFail(r, http.StatusInternalServerError, ab.ConvertDBError(err, testDBErrorConverter))
		if entity == nil {
			ab.Fail(r, http.StatusNotFound, nil)
		}

		// HOOK: insideTestDeleteHandler()

		if abort {
			return
		}

		err = entity.Delete(db)
		ab.MaybeFail(r, http.StatusInternalServerError, ab.ConvertDBError(err, testDBErrorConverter))

		// HOOK: afterTestDeleteHandler()

		if abort {
			return
		}
	})
}

func (s *Service) SchemaInstalled(db ab.DB) bool {
	found := ab.TableExists(db, "test")

	// HOOK: afterTestSchemaInstalled()

	return found
}

func (s *Service) SchemaSQL() string {
	sql := "CREATE TABLE \"test\" (\n" +
		"\t\"uuid\" uuid DEFAULT uuid_generate_v4() NOT NULL,\n" +
		"\t\"name\" character varying NOT NULL,\n" +
		"\t\"mail\" character varying NOT NULL,\n" +
		"\t\"bio\" text NOT NULL,\n" +
		"\t\"data\" jsonb NOT NULL,\n" +
		"\tCONSTRAINT test_pkey PRIMARY KEY (uuid)\n);\n"

	// HOOK: afterTestSchemaSQL()

	return sql
}
