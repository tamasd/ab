package auth

import (
	"errors"
	"net/http"
	"strconv"

	"github.com/lib/pq"
	"github.com/nbio/hitch"
	"github.com/tamasd/ab"
)

// AUTOGENERATED DO NOT EDIT

func NewTestUser() *TestUser {
	e := &TestUser{}

	// HOOK: newTestUser()

	return e
}

func EmptyTestUser() *TestUser {
	return &TestUser{}
}

var _ ab.Validator = &TestUser{}

func (e *TestUser) Validate() error {
	var err error

	// HOOK: validateTestUser()

	return err
}

func (e *TestUser) GetID() string {
	return e.UUID
}

var TestUserNotFoundError = errors.New("testuser not found")

const testuserFields = "t.uuid, t.mail"

func selectTestUserFromQuery(db ab.DB, query string, args ...interface{}) ([]*TestUser, error) {
	// HOOK: beforeTestUserSelect()

	entities := []*TestUser{}

	rows, err := db.Query(query, args...)

	if err != nil {
		return entities, err
	}

	for rows.Next() {
		e := EmptyTestUser()

		if err = rows.Scan(&e.UUID, &e.Mail); err != nil {
			return []*TestUser{}, err
		}

		entities = append(entities, e)
	}

	// HOOK: afterTestUserSelect()

	return entities, err
}

func selectSingleTestUserFromQuery(db ab.DB, query string, args ...interface{}) (*TestUser, error) {
	entities, err := selectTestUserFromQuery(db, query, args...)
	if err != nil {
		return nil, err
	}

	if len(entities) > 0 {
		return entities[0], nil
	}

	return nil, nil
}

func (e *TestUser) Insert(db ab.DB) error {
	// HOOK: beforeTestUserInsert()

	err := db.QueryRow("INSERT INTO \"testuser\"(mail) VALUES($1) RETURNING uuid", e.Mail).Scan(&e.UUID)

	// HOOK: afterTestUserInsert()

	return err
}

func (e *TestUser) Update(db ab.DB) error {
	// HOOK: beforeTestUserUpdate()

	result, err := db.Exec("UPDATE \"testuser\" SET mail = $1 WHERE uuid = $2", e.Mail, e.UUID)
	if err != nil {
		return err
	}

	aff, err := result.RowsAffected()
	if err != nil {
		return err
	}

	if aff != 1 {
		return TestUserNotFoundError
	}

	// HOOK: afterTestUserUpdate()

	return nil
}

func (e *TestUser) Delete(db ab.DB) error {
	// HOOK: beforeTestUserDelete()

	res, err := db.Exec("DELETE FROM \"testuser\" WHERE uuid = $1", e.UUID)
	if err != nil {
		return err
	}

	aff, err := res.RowsAffected()
	if err != nil {
		return err
	}

	if aff != 1 {
		return TestUserNotFoundError
	}

	// HOOK: afterTestUserDelete()

	return nil
}

func LoadTestUser(db ab.DB, UUID string) (*TestUser, error) {
	// HOOK: beforeTestUserLoad()

	e, err := selectSingleTestUserFromQuery(db, "SELECT "+testuserFields+" FROM \"testuser\" t WHERE t.uuid = $1", UUID)

	// HOOK: afterTestUserLoad()

	return e, err
}

func LoadAllTestUser(db ab.DB, start, limit int) ([]*TestUser, error) {
	// HOOK: beforeTestUserLoadAll()

	entities, err := selectTestUserFromQuery(db, "SELECT "+testuserFields+" FROM \"testuser\" t ORDER BY UUID DESC LIMIT $1 OFFSET $2", limit, start)

	// HOOK: afterTestUserLoadAll()

	return entities, err
}

type testUserService struct {
}

func (s *testUserService) Register(h *hitch.Hitch) error {
	var err error

	listMiddlewares := []func(http.Handler) http.Handler{}

	postMiddlewares := []func(http.Handler) http.Handler{}

	getMiddlewares := []func(http.Handler) http.Handler{}

	putMiddlewares := []func(http.Handler) http.Handler{}

	deleteMiddlewares := []func(http.Handler) http.Handler{}

	// HOOK: beforetestUserServiceRegister()

	if err != nil {
		return err
	}

	h.Get("/api/testuser", testuserListHandler(), listMiddlewares...)

	h.Post("/api/testuser", testuserPostHandler(), postMiddlewares...)

	h.Get("/api/testuser/:id", testuserGetHandler(), getMiddlewares...)

	h.Put("/api/testuser/:id", testuserPutHandler(), putMiddlewares...)

	h.Delete("/api/testuser/:id", testuserDeleteHandler(), deleteMiddlewares...)

	// HOOK: aftertestUserServiceRegister()

	return err
}

func testuserDBErrorConverter(err *pq.Error) ab.VerboseError {
	ve := ab.NewVerboseError(err.Message, err.Detail)

	// HOOK: convertTestUserDBError()

	return ve
}

func testuserListHandler() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		db := ab.GetDB(r)
		loadFunc := LoadAllTestUser
		abort := false
		start := 0
		limit := 25
		if page := r.URL.Query().Get("page"); page != "" {
			pagenum, err := strconv.Atoi(page)
			ab.MaybeFail(r, http.StatusBadRequest, err)
			start = (pagenum - 1) * limit
		}

		// HOOK: beforeTestUserListHandler()

		if abort {
			return
		}

		entities, err := loadFunc(db, start, limit)
		ab.MaybeFail(r, http.StatusInternalServerError, ab.ConvertDBError(err, testuserDBErrorConverter))

		// HOOK: afterTestUserListHandler()

		if abort {
			return
		}

		ab.Render(r).JSON(entities)
	})
}

func testuserPostHandler() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		entity := &TestUser{}
		ab.MustDecode(r, entity)

		abort := false

		// HOOK: testuserPostValidation()

		if abort {
			return
		}

		if err := entity.Validate(); err != nil {
			ab.Fail(r, http.StatusBadRequest, err)
		}

		db := ab.GetDB(r)

		err := entity.Insert(db)
		ab.MaybeFail(r, http.StatusInternalServerError, ab.ConvertDBError(err, testuserDBErrorConverter))

		// HOOK: afterTestUserPostInsertHandler()

		if abort {
			return
		}

		ab.Render(r).SetCode(http.StatusCreated).JSON(entity)
	})
}

func testuserGetHandler() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		id := hitch.Params(r).ByName("id")
		db := ab.GetDB(r)
		abort := false
		loadFunc := LoadTestUser

		// HOOK: beforeTestUserGetHandler()

		if abort {
			return
		}

		entity, err := loadFunc(db, id)
		ab.MaybeFail(r, http.StatusInternalServerError, ab.ConvertDBError(err, testuserDBErrorConverter))
		if entity == nil {
			ab.Fail(r, http.StatusNotFound, nil)
		}

		// HOOK: afterTestUserGetHandler()

		if abort {
			return
		}

		ab.Render(r).JSON(entity)
	})
}

func testuserPutHandler() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		id := hitch.Params(r).ByName("id")

		entity := &TestUser{}
		ab.MustDecode(r, entity)

		if err := entity.Validate(); entity.UUID != id || err != nil {
			ab.Fail(r, http.StatusBadRequest, err)
		}

		db := ab.GetDB(r)
		abort := false

		// HOOK: beforeTestUserPutUpdateHandler()

		if abort {
			return
		}

		err := entity.Update(db)
		ab.MaybeFail(r, http.StatusInternalServerError, ab.ConvertDBError(err, testuserDBErrorConverter))

		// HOOK: afterTestUserPutUpdateHandler()

		if abort {
			return
		}

		ab.Render(r).JSON(entity)
	})
}

func testuserDeleteHandler() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		id := hitch.Params(r).ByName("id")
		db := ab.GetDB(r)
		abort := false
		loadFunc := LoadTestUser

		// HOOK: beforeTestUserDeleteHandler()

		if abort {
			return
		}

		entity, err := loadFunc(db, id)
		ab.MaybeFail(r, http.StatusInternalServerError, ab.ConvertDBError(err, testuserDBErrorConverter))
		if entity == nil {
			ab.Fail(r, http.StatusNotFound, nil)
		}

		// HOOK: insideTestUserDeleteHandler()

		if abort {
			return
		}

		err = entity.Delete(db)
		ab.MaybeFail(r, http.StatusInternalServerError, ab.ConvertDBError(err, testuserDBErrorConverter))

		// HOOK: afterTestUserDeleteHandler()

		if abort {
			return
		}
	})
}

func (s *testUserService) SchemaInstalled(db ab.DB) bool {
	found := ab.TableExists(db, "testuser")

	// HOOK: afterTestUserSchemaInstalled()

	return found
}

func (s *testUserService) SchemaSQL() string {
	sql := "CREATE TABLE \"testuser\" (\n" +
		"\t\"uuid\" uuid DEFAULT uuid_generate_v4() NOT NULL,\n" +
		"\t\"mail\" character varying NOT NULL,\n" +
		"\tCONSTRAINT testuser_pkey PRIMARY KEY (uuid)\n);\n"

	// HOOK: afterTestUserSchemaSQL()

	return sql
}
