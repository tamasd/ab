package search

import (
	"errors"
	"net/http"
	"strconv"

	"github.com/lib/pq"
	"github.com/nbio/hitch"
	"github.com/tamasd/ab"
)

// AUTOGENERATED DO NOT EDIT

func NewTestContent() *TestContent {
	e := &TestContent{}

	// HOOK: newTestContent()

	return e
}

func EmptyTestContent() *TestContent {
	return &TestContent{}
}

var _ ab.Validator = &TestContent{}

func (e *TestContent) Validate() error {
	var err error

	// HOOK: validateTestContent()

	return err
}

func (e *TestContent) GetID() string {
	return e.UUID
}

var TestContentNotFoundError = errors.New("testcontent not found")

const testcontentFields = "t.uuid, t.owner, t.title, t.content"

func selectTestContentFromQuery(db ab.DB, query string, args ...interface{}) ([]*TestContent, error) {
	// HOOK: beforeTestContentSelect()

	entities := []*TestContent{}

	rows, err := db.Query(query, args...)

	if err != nil {
		return entities, err
	}

	for rows.Next() {
		e := EmptyTestContent()

		if err = rows.Scan(&e.UUID, &e.Owner, &e.Title, &e.Content); err != nil {
			return []*TestContent{}, err
		}

		entities = append(entities, e)
	}

	// HOOK: afterTestContentSelect()

	return entities, err
}

func selectSingleTestContentFromQuery(db ab.DB, query string, args ...interface{}) (*TestContent, error) {
	entities, err := selectTestContentFromQuery(db, query, args...)
	if err != nil {
		return nil, err
	}

	if len(entities) > 0 {
		return entities[0], nil
	}

	return nil, nil
}

func (e *TestContent) Insert(db ab.DB) error {
	// HOOK: beforeTestContentInsert()

	err := db.QueryRow("INSERT INTO \"testcontent\"(owner, title, content) VALUES($1, $2, $3) RETURNING uuid", e.Owner, e.Title, e.Content).Scan(&e.UUID)

	// HOOK: afterTestContentInsert()

	return err
}

func (e *TestContent) Update(db ab.DB) error {
	// HOOK: beforeTestContentUpdate()

	result, err := db.Exec("UPDATE \"testcontent\" SET owner = $1, title = $2, content = $3 WHERE uuid = $4", e.Owner, e.Title, e.Content, e.UUID)
	if err != nil {
		return err
	}

	aff, err := result.RowsAffected()
	if err != nil {
		return err
	}

	if aff != 1 {
		return TestContentNotFoundError
	}

	// HOOK: afterTestContentUpdate()

	return nil
}

func (e *TestContent) Delete(db ab.DB) error {
	// HOOK: beforeTestContentDelete()

	res, err := db.Exec("DELETE FROM \"testcontent\" WHERE uuid = $1", e.UUID)
	if err != nil {
		return err
	}

	aff, err := res.RowsAffected()
	if err != nil {
		return err
	}

	if aff != 1 {
		return TestContentNotFoundError
	}

	// HOOK: afterTestContentDelete()

	return nil
}

func LoadTestContent(db ab.DB, UUID string) (*TestContent, error) {
	// HOOK: beforeTestContentLoad()

	e, err := selectSingleTestContentFromQuery(db, "SELECT "+testcontentFields+" FROM \"testcontent\" t WHERE t.uuid = $1", UUID)

	// HOOK: afterTestContentLoad()

	return e, err
}

func LoadAllTestContent(db ab.DB, start, limit int) ([]*TestContent, error) {
	// HOOK: beforeTestContentLoadAll()

	entities, err := selectTestContentFromQuery(db, "SELECT "+testcontentFields+" FROM \"testcontent\" t ORDER BY UUID DESC LIMIT $1 OFFSET $2", limit, start)

	// HOOK: afterTestContentLoadAll()

	return entities, err
}

type testContentService struct {
}

func (s *testContentService) Register(h *hitch.Hitch) error {
	var err error

	listMiddlewares := []func(http.Handler) http.Handler{}

	postMiddlewares := []func(http.Handler) http.Handler{}

	getMiddlewares := []func(http.Handler) http.Handler{}

	putMiddlewares := []func(http.Handler) http.Handler{}

	deleteMiddlewares := []func(http.Handler) http.Handler{}

	// HOOK: beforetestContentServiceRegister()

	if err != nil {
		return err
	}

	h.Get("/api/testcontent", s.testcontentListHandler(), listMiddlewares...)

	h.Post("/api/testcontent", s.testcontentPostHandler(), postMiddlewares...)

	h.Get("/api/testcontent/:id", s.testcontentGetHandler(), getMiddlewares...)

	h.Put("/api/testcontent/:id", s.testcontentPutHandler(), putMiddlewares...)

	h.Delete("/api/testcontent/:id", s.testcontentDeleteHandler(), deleteMiddlewares...)

	// HOOK: aftertestContentServiceRegister()

	return err
}

func testcontentDBErrorConverter(err *pq.Error) ab.VerboseError {
	ve := ab.NewVerboseError(err.Message, err.Detail)

	// HOOK: convertTestContentDBError()

	return ve
}

func (s *testContentService) testcontentListHandler() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		db := ab.GetDB(r)
		loadFunc := LoadAllTestContent
		abort := false
		start := 0
		limit := 25
		if page := r.URL.Query().Get("page"); page != "" {
			pagenum, err := strconv.Atoi(page)
			ab.MaybeFail(r, http.StatusBadRequest, err)
			start = (pagenum - 1) * limit
		}

		// HOOK: beforeTestContentListHandler()

		if abort {
			return
		}

		entities, err := loadFunc(db, start, limit)
		ab.MaybeFail(r, http.StatusInternalServerError, ab.ConvertDBError(err, testcontentDBErrorConverter))

		// HOOK: afterTestContentListHandler()

		if abort {
			return
		}

		ab.Render(r).JSON(entities)
	})
}

func (s *testContentService) testcontentPostHandler() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		entity := &TestContent{}
		ab.MustDecode(r, entity)

		abort := false

		// HOOK: testcontentPostValidation()

		if abort {
			return
		}

		if err := entity.Validate(); err != nil {
			ab.Fail(r, http.StatusBadRequest, err)
		}

		db := ab.GetDB(r)

		err := entity.Insert(db)
		ab.MaybeFail(r, http.StatusInternalServerError, ab.ConvertDBError(err, testcontentDBErrorConverter))

		// HOOK: afterTestContentPostInsertHandler()

		if abort {
			return
		}

		ab.Render(r).SetCode(http.StatusCreated).JSON(entity)
	})
}

func (s *testContentService) testcontentGetHandler() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		id := hitch.Params(r).ByName("id")
		db := ab.GetDB(r)
		abort := false
		loadFunc := LoadTestContent

		// HOOK: beforeTestContentGetHandler()

		if abort {
			return
		}

		entity, err := loadFunc(db, id)
		ab.MaybeFail(r, http.StatusInternalServerError, ab.ConvertDBError(err, testcontentDBErrorConverter))
		if entity == nil {
			ab.Fail(r, http.StatusNotFound, nil)
		}

		// HOOK: afterTestContentGetHandler()

		if abort {
			return
		}

		ab.Render(r).JSON(entity)
	})
}

func (s *testContentService) testcontentPutHandler() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		id := hitch.Params(r).ByName("id")

		entity := &TestContent{}
		ab.MustDecode(r, entity)

		if err := entity.Validate(); entity.UUID != id || err != nil {
			ab.Fail(r, http.StatusBadRequest, err)
		}

		db := ab.GetDB(r)
		abort := false

		// HOOK: beforeTestContentPutUpdateHandler()

		if abort {
			return
		}

		err := entity.Update(db)
		ab.MaybeFail(r, http.StatusInternalServerError, ab.ConvertDBError(err, testcontentDBErrorConverter))

		// HOOK: afterTestContentPutUpdateHandler()

		if abort {
			return
		}

		ab.Render(r).JSON(entity)
	})
}

func (s *testContentService) testcontentDeleteHandler() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		id := hitch.Params(r).ByName("id")
		db := ab.GetDB(r)
		abort := false
		loadFunc := LoadTestContent

		// HOOK: beforeTestContentDeleteHandler()

		if abort {
			return
		}

		entity, err := loadFunc(db, id)
		ab.MaybeFail(r, http.StatusInternalServerError, ab.ConvertDBError(err, testcontentDBErrorConverter))
		if entity == nil {
			ab.Fail(r, http.StatusNotFound, nil)
		}

		// HOOK: insideTestContentDeleteHandler()

		if abort {
			return
		}

		err = entity.Delete(db)
		ab.MaybeFail(r, http.StatusInternalServerError, ab.ConvertDBError(err, testcontentDBErrorConverter))

		// HOOK: afterTestContentDeleteHandler()

		if abort {
			return
		}
	})
}

func (s *testContentService) SchemaInstalled(db ab.DB) bool {
	found := ab.TableExists(db, "testcontent")

	// HOOK: afterTestContentSchemaInstalled()

	return found
}

func (s *testContentService) SchemaSQL() string {
	sql := "CREATE TABLE \"testcontent\" (\n" +
		"\t\"uuid\" uuid DEFAULT uuid_generate_v4() NOT NULL,\n" +
		"\t\"owner\" uuid NOT NULL,\n" +
		"\t\"title\" character varying NOT NULL,\n" +
		"\t\"content\" character varying NOT NULL,\n" +
		"\tCONSTRAINT testcontent_pkey PRIMARY KEY (uuid)\n);\n"

	// HOOK: afterTestContentSchemaSQL()

	return sql
}
